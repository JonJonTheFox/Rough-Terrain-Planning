import os
import glob
import csv
from typing import List, Dict, Iterable
import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np

label_mapping = {
    33: 'animal',
    23: 'asphalt',
    60: 'barrel',
    48: 'barrier_tape',
    13: 'bicycle',
    7: 'bikeway',
    25: 'boom_barrier',
    43: 'bridge',
    38: 'building',
    15: 'bus',
    17: 'bush',
    12: 'car',
    36: 'caravan',
    3: 'cobble',
    58: 'container',
    30: 'crops',
    22: 'curb',
    29: 'debris',
    8: 'ego_vehicle',
    41: 'fence',
    16: 'forest',
    24: 'gravel',
    42: 'guard_rail',
    57: 'heavy_machinery',
    59: 'hedge',
    51: 'high_grass',
    49: 'kick_scooter',
    5: 'leaves',
    50: 'low_grass',
    63: 'military_vehicle',
    47: 'misc_sign',
    18: 'moss',
    20: 'motorcycle',
    4: 'obstacle',
    35: 'on_rails',
    56: 'outlier',
    9: 'pedestrian_crossing',
    14: 'person',
    61: 'pipe',
    45: 'pole',
    26: 'rail_track',
    32: 'rider',
    10: 'road_block',
    11: 'road_marking',
    40: 'rock',
    52: 'scenery_vegetation',
    21: 'sidewalk',
    53: 'sky',
    2: 'snow',
    31: 'soil',
    6: 'street_light',
    1: 'traffic_cone',
    19: 'traffic_light',
    46: 'traffic_sign',
    37: 'trailer',
    27: 'tree_crown',
    62: 'tree_root',
    28: 'tree_trunk',
    34: 'truck',
    44: 'tunnel',
    0: 'undefined',
    39: 'wall',
    54: 'water',
    55: 'wire'
}


def __check_labels(img_path: str, lbl_path: str) -> bool:
    '''
    Check if pair of labels and images exist. Filter non-existing pairs.
    '''
    name = os.path.basename(img_path)
    name, ext = name.split('.')
    name = name.split('_')[:-2]
    name = '_'.join(name)

    names = []
    for l in ['color', 'instanceids', 'labelids']:
        # Check if label exists
        lbl_name = name + '_' + l + '.' + ext
        if not os.path.exists(os.path.join(lbl_path, lbl_name)):
            return False, None
        names.append(lbl_name)

    return True, names

def __goose_datadict_folder(img_path: str, lbl_path: str):
    '''
    Create a data Dictionary with image paths
    '''
    subfolders = glob.glob(os.path.join(img_path, '*/'), recursive=False)
    subfolders = [f.split('/')[-2] for f in subfolders]

    valid_imgs = []
    valid_lbls = []
    valid_insta = []
    valid_color = []

    datadict = []

    for s in subfolders:
        imgs_p = os.path.join(img_path, s)
        lbls_p = os.path.join(lbl_path, s)
        imgs = glob.glob(os.path.join(imgs_p, '*.png'))
        for i in imgs:
            valid, lbl_names = __check_labels(i, lbls_p)
            if not valid:
                continue

            valid_imgs.append(i)
            valid_color.append(os.path.join(lbls_p, lbl_names[0]))
            valid_insta.append(os.path.join(lbls_p, lbl_names[1]))
            valid_lbls.append(os.path.join(lbls_p, lbl_names[2]))

    for i, m, p, c in zip(valid_imgs, valid_lbls, valid_insta, valid_color):
        datadict.append({
            'img_path': i,
            'semantic_path': m,
            'instance_path': p,
            'color_path': c,
        })

    return datadict

def goose_create_dataDict(src_path: str, mapping_csv_name: str = 'goose_label_mapping.csv') -> Dict:
    '''
    Parameters:
        src_path            :   path to dataset

    Returns:
        datadict_train      : dict with the dataset train images information
        datadict_val        : dict with the dataset validation images information
        datadict_test       : dict with the dataset test images information
    '''
    if mapping_csv_name is not None:
        mapping_path = os.path.join(src_path, mapping_csv_name)
        mapping = []
        with open(mapping_path, newline='') as f:
            reader = csv.DictReader(f)
            for r in reader:
                mapping.append(r)
    else:
        mapping = None

    img_path = os.path.join(src_path, 'images')
    lbl_path = os.path.join(src_path, 'labels')

    datadicts = []
    for c in ['test', 'train', 'val']:
        print("### " + c.capitalize() + " Data ###")
        datadicts.append(
            __goose_datadict_folder(
                os.path.join(img_path, c),
                os.path.join(lbl_path, c)
            )
        )

    test, train, val = datadicts

    return test, train, val, mapping


class GOOSE_SemanticDataset(Dataset):
    """
    Example Pytorch Dataset Module for semantic tasks with GOOSE.
    """

    def __init__(self, dataset_dict: List[Dict], crop: bool = True, resize_size: Iterable[int] = None):
        '''
        Parameters:
            dataset_dict  [Iter]    : List of  Dicts with the images information generated by *goose_create_dataDict*
            crop          [Bool]    : Whether to make a square crop of the images or not
            resize_size   [Iter]    : List with the target resize size of the images (After the crop if crop == True)
        '''
        self.dataset_dict = dataset_dict
        self.transforms = transforms.Compose([
            transforms.ToTensor(),
        ])
        self.resize_size = resize_size
        self.crop = crop

    def preprocess(self, image, index_in_ninth):
        if image is None:
            return None

        if self.crop:
            # Square-Crop in the center
            s = min([image.width, image.height])
            image = transforms.CenterCrop((s, s)).forward(image)

        # Resize to given size
        if self.resize_size is not None:
            image = image.resize(self.resize_size, resample=Image.NEAREST)

        # Cut the image into ninths
        width, height = image.size
        grid_width = width // 3
        grid_height = height // 3

        row = index_in_ninth // 3
        col = index_in_ninth % 3

        left = col * grid_width
        upper = row * grid_height
        right = left + grid_width
        lower = upper + grid_height

        # Crop the image to the specified ninth
        image = image.crop((left, upper, right, lower))

        return image

    def __getitem__(self, i):
        '''
        Parameter:
            i   [int]                   : Index of the image to get

        Returns:
            image_tensor [torch.Tensor] : 3 x H x W Tensor
            label_tensor [torch.Tensor] : H x W Tensor as semantic map
        '''
        # Adjust index to access both the image and the ninth part index
        img_index = i // 9
        ninth_index = i % 9

        image = Image.open(self.dataset_dict[img_index]['img_path']).convert('RGB')
        label = Image.open(self.dataset_dict[img_index]['semantic_path']).convert('L')

        # Preprocess to get the specific ninth
        image = self.preprocess(image, ninth_index)
        label = self.preprocess(label, ninth_index)

        image_tensor = self.transforms(image)
        label_tensor = torch.from_numpy(np.array(label)).long()

        return image_tensor, label_tensor

    def __len__(self):
        # Length is multiplied by 9 since each image has 9 parts
        return len(self.dataset_dict) * 9

    def visualize_sample(self, index):
        '''
        Visualize the full image and its corresponding label,
        alongside the selected ninth part of the image and its label.
        '''
        img_index = index // 9
        ninth_index = index % 9

        # Load the full image and label
        full_image = Image.open(self.dataset_dict[img_index]['img_path']).convert('RGB')
        full_label = Image.open(self.dataset_dict[img_index]['semantic_path']).convert('L')

        # Preprocess to get the specific ninth
        ninth_image = self.preprocess(full_image.copy(), ninth_index)
        ninth_label = self.preprocess(full_label.copy(), ninth_index)

        # Convert images to tensors for visualization
        full_image_tensor = self.transforms(full_image)
        ninth_image_tensor = self.transforms(ninth_image)

        full_label_tensor = torch.from_numpy(np.array(full_label)).long()
        ninth_label_tensor = torch.from_numpy(np.array(ninth_label)).long()

        # Convert tensors to numpy arrays for visualization
        full_image_np = full_image_tensor.permute(1, 2, 0).numpy()  # H x W x C
        ninth_image_np = ninth_image_tensor.permute(1, 2, 0).numpy()  # H x W x C

        full_label_np = full_label_tensor.numpy()  # H x W
        ninth_label_np = ninth_label_tensor.numpy()  # H x W

        # Plotting
        fig, axs = plt.subplots(2, 2, figsize=(12, 12))

        # Full Image
        axs[0, 0].imshow(full_image_np)
        axs[0, 0].set_title("Full Image")
        axs[0, 0].axis('off')

        # Full Label
        full_label_img = axs[0, 1].imshow(full_label_np, cmap='tab20')
        axs[0, 1].set_title("Full Label")
        axs[0, 1].axis('off')

        # Ninth Image
        axs[1, 0].imshow(ninth_image_np)
        axs[1, 0].set_title("Ninth Image")
        axs[1, 0].axis('off')

        # Ninth Label
        ninth_label_img = axs[1, 1].imshow(ninth_label_np, cmap='tab20')
        axs[1, 1].set_title("Ninth Label")
        axs[1, 1].axis('off')

        # Function to display class label name on hover
        def on_hover(event):
            if event.inaxes == axs[1, 1]:
                # Get mouse position and corresponding label
                x, y = int(event.xdata), int(event.ydata)
                if x >= 0 and y >= 0 and x < ninth_label_np.shape[1] and y < ninth_label_np.shape[0]:
                    label_id = ninth_label_np[y, x]
                    label_name = label_mapping.get(label_id, f"Unknown ID {label_id}")
                    axs[1, 1].set_title(f"Ninth Label (Hover: {label_name})")
                    fig.canvas.draw_idle()
            elif event.inaxes == axs[0, 1]:
                # Get mouse position and corresponding label for full image
                x, y = int(event.xdata), int(event.ydata)
                if x >= 0 and y >= 0 and x < full_label_np.shape[1] and y < full_label_np.shape[0]:
                    label_id = full_label_np[y, x]
                    label_name = label_mapping.get(label_id, f"Unknown ID {label_id}")
                    axs[0, 1].set_title(f"Full Label (Hover: {label_name})")
                    fig.canvas.draw_idle()

        # Connect the hover event
        fig.canvas.mpl_connect("motion_notify_event", on_hover)

        plt.show()


# Example usage:
src_path = "/Users/YehonatanMileguir/GOOSE/goose_2d_train"  # Replace with your dataset path
test_dict, train_dict, val_dict, mapping = goose_create_dataDict(src_path)
print(f"Train dict length: {len(train_dict)}")
print(f"Validation dict length: {len(val_dict)}")
print(f"Test dict length: {len(test_dict)}")


# Create Dataset objects for train, validation, and test sets
train_dataset = GOOSE_SemanticDataset(dataset_dict=train_dict, crop=True, resize_size=(256, 256))
val_dataset = GOOSE_SemanticDataset(dataset_dict=val_dict, crop=True, resize_size=(256, 256))
test_dataset = GOOSE_SemanticDataset(dataset_dict=test_dict, crop=True, resize_size=(256, 256))

# Visualize the first sample in the training set
train_dataset.visualize_sample(30)

# Create DataLoader objects if needed
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)
